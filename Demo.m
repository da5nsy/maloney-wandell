clear, clc, close all

%load CIE basis functions
load B_cieday.mat B_cieday S_cieday

%load Vrhel natural surfaces basis functions
load B_vrhel.mat B_vrhel S_vrhel
B_vrhel = SplineSrf(S_vrhel,B_vrhel,S_cieday,1);

%%%% configration  %%
nSensors = 3; % number of sensors
nSurfaces = 100; % number of surfaces reflectances to solve
%%%%%%%%%%%%%%%%%%%%%

switch nSensors
case 3
    load T_cones_ss10.mat
    sensorResCur = SplineCmf(S_cones_ss10,T_cones_ss10,S_cieday,1)';
    %load data/RGB
    %sensorResCur = RGB;
case 4
    load data/sensor4
    sensorResCur = sensor4;
otherwise
    throw(MException('ResultChk:OutOfRange', ...
        'Test data is only available for 3 or 4 sensors'));
end

% Select some bases

lightB = B_cieday; %previously here the code seemed to pick nSensors daylight measurements. B_cieday is limited to 3 (more could be generated by using the Granada data)
figure, plot(lightB); title('Light Basis Functions')
surfB = B_vrhel(:,1:nSensors-1);
figure, plot(surfB); title('Surface Basis Functions')

% Create an illuminant and some surfaces from the basis functions with random weights
IllumWeights = rand(size(lightB, 2),1);
trueIllum = lightB*IllumWeights; % 31x1
figure, plot(trueIllum); title('True Illuminant')
trueSurfA = surfB*rand(size(surfB, 2),nSurfaces); % 31xn
figure, plot(trueSurfA); title('True Surfaces')

% Generate sensors responses from illuminant and surfaces
sensorRes = (repmat(trueIllum, 1, nSurfaces).*trueSurfA)' * sensorResCur; % nx3
figure, scatter3(sensorRes(:,1),sensorRes(:,2),sensorRes(:,3)); title('Sensor Responses')

% Run the algorithm
[estIllum, estSurfA, epsilon] = maloneywandell(lightB, surfB, sensorResCur, sensorRes);

figure,
plot([trueIllum, estIllum]);

% % original lighting and reflectance
% sensorRes = repmat(trueIllum, 1, nSurfaces)' * sensorResCur; % nx3
% surfRes = trueSurfA' * sensorResCur; % nx3
% % recovered lighting and reflectance
% EsensorRes = repmat(estIllum, 1, nSurfaces)' * sensorResCur; % nx3
% EsurfRes = estSurfA' * sensorResCur; % nx3

% plot them
% figure('Name','Simulation Results for All Surface Reflectance Recovery Tests');
% for i = 1:nSurfaces
%     subplot(3,ceil(nSurfaces/3),i);
%     trueSurf = trueSurfA(:,i);
%     estSurf = estSurfA(:,i);
%     % Plot the true surface reflectance against the estimate
%     plot([trueSurf, estSurf]);
%     %legend('True','Est.');
%     yticks([])
% end

% figure('Name','Recovery Visualisation');
% Eim = reshape(sensorRes,[3,ceil(nSurfaces/3),3]);
% Sim = reshape(surfRes,[3,ceil(nSurfaces/3),3]);
% eEim = reshape(EsensorRes,[3,ceil(nSurfaces/3),3]);
% eSim = reshape(EsurfRes,[3,ceil(nSurfaces/3),3]);
% subplot(2,2,1); imshow(Eim); title('original illuminant');
% subplot(2,2,2); imshow(Sim); title('original reflectance');
% subplot(2,2,3); imshow(eEim); title('estimated illuminant');
% subplot(2,2,4); imshow(eSim); title('estimated reflectance');

